use reqwest::Method;
use serde::{Deserialize, Serialize};
use serde_json::{json, Value};
use std::fmt;
use tracing::{debug, info, warn};

use super::indexer_client::WazuhIndexerClient;
use super::wazuh_client::WazuhApiClient;

mod string_or_number_as_string {
    use serde::{Deserialize, Deserializer};

    pub fn deserialize<'de, D>(deserializer: D) -> Result<String, D::Error>
    where
        D: Deserializer<'de>,
    {
        #[derive(Deserialize)]
        #[serde(untagged)]
        enum StringOrNumber {
            Str(String),
            Num(serde_json::Number),
        }

        match StringOrNumber::deserialize(deserializer)? {
            StringOrNumber::Str(s) => Ok(s),
            StringOrNumber::Num(n) => Ok(n.to_string()),
        }
    }

    pub fn deserialize_optional<'de, D>(deserializer: D) -> Result<Option<String>, D::Error>
    where
        D: Deserializer<'de>,
    {
        #[derive(Deserialize)]
        #[serde(untagged)]
        enum StringOrNumberOrNull {
            Str(String),
            Num(serde_json::Number),
        }

        let intermediate: Option<StringOrNumberOrNull> = Option::deserialize(deserializer)?;

        match intermediate {
            Some(StringOrNumberOrNull::Str(s)) => Ok(Some(s)),
            Some(StringOrNumberOrNull::Num(n)) => Ok(Some(n.to_string())),
            None => Ok(None),
        }
    }
}
use super::error::WazuhApiError;

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "PascalCase")]
pub enum VulnerabilitySeverity {
    Critical,
    High,
    Medium,
    Low,
}

impl VulnerabilitySeverity {
    /// Convert to the format expected by the Wazuh indexer (first letter uppercase, rest lowercase)
    pub fn to_indexer_format(&self) -> &'static str {
        match self {
            VulnerabilitySeverity::Critical => "Critical",
            VulnerabilitySeverity::High => "High",
            VulnerabilitySeverity::Medium => "Medium",
            VulnerabilitySeverity::Low => "Low",
        }
    }

    /// Parse from string (case-insensitive)
    pub fn from_str(s: &str) -> Option<Self> {
        match s.to_lowercase().as_str() {
            "critical" => Some(VulnerabilitySeverity::Critical),
            "high" => Some(VulnerabilitySeverity::High),
            "medium" => Some(VulnerabilitySeverity::Medium),
            "low" => Some(VulnerabilitySeverity::Low),
            _ => None,
        }
    }

    /// Get all severity levels in order from highest to lowest
    pub fn all() -> [VulnerabilitySeverity; 4] {
        [
            VulnerabilitySeverity::Critical,
            VulnerabilitySeverity::High,
            VulnerabilitySeverity::Medium,
            VulnerabilitySeverity::Low,
        ]
    }
}

impl fmt::Display for VulnerabilitySeverity {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.to_indexer_format())
    }
}

impl From<VulnerabilitySeverity> for String {
    fn from(severity: VulnerabilitySeverity) -> Self {
        severity.to_indexer_format().to_string()
    }
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct Vulnerability {
    pub cve: String,
    pub title: String,
    #[serde(deserialize_with = "deserialize_severity")]
    pub severity: VulnerabilitySeverity,
    pub published: Option<String>,
    pub updated: Option<String>,
    pub reference: Option<String>,
    pub description: Option<String>,
    pub cvss: Option<CvssScore>,
    pub detection_time: Option<String>,
    pub agent_id: Option<String>,
    pub agent_name: Option<String>,
}

fn deserialize_severity<'de, D>(deserializer: D) -> Result<VulnerabilitySeverity, D::Error>
where
    D: serde::Deserializer<'de>,
{
    let s = String::deserialize(deserializer)?;
    VulnerabilitySeverity::from_str(&s)
        .ok_or_else(|| serde::de::Error::custom(format!("Invalid severity: {}", s)))
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct CvssScore {
    pub cvss2: Option<CvssDetails>,
    pub cvss3: Option<CvssDetails>,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct CvssDetails {
    pub vector: Option<String>,
    pub base_score: Option<f64>,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct Package {
    pub name: String,
    pub version: String,
    pub architecture: Option<String>,
    pub format: Option<String>,
    pub description: Option<String>,
    pub size: Option<u64>,
    pub vendor: Option<String>,
    pub multiarch: Option<String>,
    pub source: Option<String>,
    pub priority: Option<String>,
    pub scan_id: Option<u64>,
    pub section: Option<String>,
    pub agent_id: Option<String>,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct Process {
    #[serde(deserialize_with = "string_or_number_as_string::deserialize")]
    pub pid: String,
    pub name: String,
    pub state: Option<String>,
    #[serde(
        default,
        deserialize_with = "string_or_number_as_string::deserialize_optional"
    )]
    pub ppid: Option<String>,
    #[serde(
        default,
        deserialize_with = "string_or_number_as_string::deserialize_optional"
    )]
    pub utime: Option<String>,
    #[serde(
        default,
        deserialize_with = "string_or_number_as_string::deserialize_optional"
    )]
    pub stime: Option<String>,
    pub cmd: Option<String>,
    pub argvs: Option<String>,
    pub euser: Option<String>,
    pub ruser: Option<String>,
    pub suser: Option<String>,
    pub egroup: Option<String>,
    pub rgroup: Option<String>,
    pub sgroup: Option<String>,
    pub fgroup: Option<String>,
    pub priority: Option<i32>,
    pub nice: Option<i32>,
    pub size: Option<u64>,
    pub vm_size: Option<u64>,
    pub resident: Option<u64>,
    pub share: Option<u64>,
    #[serde(
        default,
        deserialize_with = "string_or_number_as_string::deserialize_optional"
    )]
    pub start_time: Option<String>,
    #[serde(
        default,
        deserialize_with = "string_or_number_as_string::deserialize_optional"
    )]
    pub pgrp: Option<String>,
    #[serde(
        default,
        deserialize_with = "string_or_number_as_string::deserialize_optional"
    )]
    pub session: Option<String>,
    pub nlwp: Option<u32>,
    #[serde(
        default,
        deserialize_with = "string_or_number_as_string::deserialize_optional"
    )]
    pub tgid: Option<String>,
    #[serde(
        default,
        deserialize_with = "string_or_number_as_string::deserialize_optional"
    )]
    pub tty: Option<String>,
    #[serde(
        default,
        deserialize_with = "string_or_number_as_string::deserialize_optional"
    )]
    pub processor: Option<String>,
    pub scan_id: Option<u64>,
    pub agent_id: Option<String>,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct Port {
    pub local: PortInfo,
    pub remote: Option<PortInfo>,
    pub state: Option<String>,
    pub protocol: String,
    pub tx_queue: Option<u32>,
    pub rx_queue: Option<u32>,
    pub inode: Option<u64>,
    pub process: Option<String>,
    pub scan_id: Option<u64>,
    pub agent_id: Option<String>,
    pub pid: Option<u32>,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct VulnerabilitySummaryCounts {
    pub critical: i32,
    pub high: i32,
    pub medium: i32,
    pub low: i32,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct VulnerabilitySummaryResponseData {
    pub agent_id: String,
    pub summary: VulnerabilitySummaryCounts,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct PortInfo {
    pub ip: Option<String>,
    pub port: u16,
}

// Syscollector data structures

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct SyscollectorHardware {
    pub board_serial: Option<String>,
    pub cpu: Option<HardwareCpu>,
    pub ram: Option<HardwareRam>,
    pub scan: Option<ScanInfo>,
    pub agent_id: Option<String>,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct HardwareCpu {
    pub cores: Option<i32>,
    pub mhz: Option<f64>,
    pub name: Option<String>,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct HardwareRam {
    pub free: Option<i32>,
    pub total: Option<i32>,
    pub usage: Option<i32>,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct ScanInfo {
    pub id: Option<i64>,
    pub time: Option<String>,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct SyscollectorOS {
    pub architecture: Option<String>,
    pub hostname: Option<String>,
    pub os: Option<OSInfo>,
    pub release: Option<String>,
    pub scan: Option<ScanInfo>,
    pub sysname: Option<String>,
    pub version: Option<String>,
    pub agent_id: Option<String>,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct OSInfo {
    pub codename: Option<String>,
    pub major: Option<String>,
    pub minor: Option<String>,
    pub name: Option<String>,
    pub platform: Option<String>,
    pub version: Option<String>,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct SyscollectorNetworkInterface {
    pub mac: Option<String>,
    pub mtu: Option<i32>,
    pub name: Option<String>,
    pub rx: Option<NetworkInterfacePackets>,
    pub scan: Option<ScanInfo>,
    pub state: Option<String>,
    pub tx: Option<NetworkInterfacePackets>,
    #[serde(rename = "type")]
    pub interface_type: Option<String>,
    pub agent_id: Option<String>,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct NetworkInterfacePackets {
    pub bytes: Option<i32>,
    pub dropped: Option<i32>,
    #[serde(rename = "error")]
    pub errors: Option<i32>,
    pub packets: Option<i32>,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct SyscollectorNetworkAddress {
    pub address: Option<String>,
    pub broadcast: Option<String>,
    pub iface: Option<String>,
    pub netmask: Option<String>,
    pub proto: Option<String>,
    pub scan_id: Option<i64>,
    pub agent_id: Option<String>,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct SyscollectorNetworkProtocol {
    pub dhcp: Option<String>,
    pub gateway: Option<String>,
    pub iface: Option<String>,
    pub scan_id: Option<i64>,
    #[serde(rename = "type")]
    pub protocol_type: Option<String>,
    pub agent_id: Option<String>,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct SyscollectorHotfix {
    pub hotfix: Option<String>,
    pub scan: Option<ScanInfo>,
    pub agent_id: Option<String>,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct SyscollectorUser {
    pub scan: Option<ScanInfo>,
    pub agent_id: Option<String>,
    pub user: Option<UserInfo>,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct UserInfo {
    pub name: Option<String>,
    pub full_name: Option<String>,
    pub home: Option<String>,
    pub id: Option<i32>,
    pub uid_signed: Option<i32>,
    pub uuid: Option<String>,
    pub groups: Option<String>,
    pub group_id: Option<i32>,
    pub group_id_signed: Option<i32>,
    pub created: Option<f64>,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct SyscollectorGroup {
    pub scan: Option<ScanInfo>,
    pub agent_id: Option<String>,
    pub group: Option<GroupInfo>,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct GroupInfo {
    pub id: Option<i32>,
    pub name: Option<String>,
    pub description: Option<String>,
    pub id_signed: Option<i32>,
    pub uuid: Option<String>,
    pub is_hidden: Option<i32>,
    pub users: Option<String>,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct SyscollectorService {
    pub scan: Option<ScanInfo>,
    pub agent_id: Option<String>,
    pub service: Option<ServiceInfo>,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct ServiceInfo {
    pub id: Option<String>,
    pub name: Option<String>,
    pub description: Option<String>,
    #[serde(rename = "type")]
    pub service_type: Option<String>,
    pub state: Option<String>,
    pub sub_state: Option<String>,
    pub enabled: Option<String>,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct SyscollectorBrowserExtension {
    pub scan: Option<ScanInfo>,
    pub agent_id: Option<String>,
    pub browser: Option<BrowserInfo>,
    pub file_hash: Option<FileHashInfo>,
    pub package: Option<BrowserExtensionPackage>,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct BrowserInfo {
    pub name: Option<String>,
    pub profile_name: Option<String>,
    pub profile_path: Option<String>,
    pub profile_referenced: Option<bool>,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct FileHashInfo {
    pub sha256: Option<String>,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct BrowserExtensionPackage {
    pub name: Option<String>,
    pub version: Option<String>,
    pub description: Option<String>,
    pub author: Option<String>,
    pub homepage_url: Option<String>,
}

#[derive(Debug, Clone)]
pub struct VulnerabilityClient {
    api_client: WazuhApiClient,
    indexer_client: WazuhIndexerClient,
}

impl VulnerabilityClient {
    pub fn new(api_client: WazuhApiClient, indexer_client: WazuhIndexerClient) -> Self {
        Self {
            api_client,
            indexer_client,
        }
    }

    pub async fn get_agent_vulnerabilities(
        &mut self,
        agent_id: &str,
        limit: Option<u32>,
        offset: Option<u32>,
        severity: Option<VulnerabilitySeverity>,
    ) -> Result<Vec<Vulnerability>, WazuhApiError> {
        debug!(%agent_id, ?severity, "Getting vulnerabilities for agent");

        let size = limit.unwrap_or(100);
        let from = offset.unwrap_or(0);

        let mut must_clauses = vec![json!({
            "term": {
                "agent.id": agent_id
            }
        })];

        if let Some(severity) = severity {
            must_clauses.push(json!({
                "term": {
                    "vulnerability.severity": severity.to_indexer_format()
                }
            }));
        }

        let query_body = json!({
            "size": size,
            "from": from,
            "query": {
                "bool": {
                    "must": must_clauses
                }
            }
        });

        let endpoint = "/wazuh-states-vulnerabilities*/_search";
        let response = self
            .indexer_client
            .make_indexer_request(Method::POST, endpoint, Some(query_body))
            .await?;

        let hits = response
            .get("hits")
            .and_then(|h| h.get("hits"))
            .and_then(|h_array| h_array.as_array())
            .ok_or_else(|| {
                WazuhApiError::ApiError("Missing 'hits.hits' in vulnerability response".to_string())
            })?;

        let mut vulnerabilities = Vec::new();
        for hit in hits {
            if let Some(source) = hit.get("_source") {
                if let Ok(vuln) = self.parse_vulnerability_from_source(source, agent_id) {
                    vulnerabilities.push(vuln);
                }
            }
        }

        info!(%agent_id, "Retrieved {} vulnerabilities", vulnerabilities.len());
        Ok(vulnerabilities)
    }

    fn parse_vulnerability_from_source(
        &self,
        source: &Value,
        agent_id: &str,
    ) -> Result<Vulnerability, WazuhApiError> {
        let vulnerability_data = source.get("vulnerability").ok_or_else(|| {
            WazuhApiError::ApiError("Missing vulnerability data in source".to_string())
        })?;

        let cve = vulnerability_data
            .get("cve")
            .and_then(|v| v.as_str())
            .unwrap_or("Unknown")
            .to_string();

        let title = vulnerability_data
            .get("title")
            .and_then(|v| v.as_str())
            .unwrap_or("No title available")
            .to_string();

        let severity = vulnerability_data
            .get("severity")
            .and_then(|v| v.as_str())
            .and_then(|s| VulnerabilitySeverity::from_str(s))
            .unwrap_or(VulnerabilitySeverity::Low); // Default to Low if parsing fails

        let published = vulnerability_data
            .get("published")
            .and_then(|v| v.as_str())
            .map(|s| s.to_string());

        let updated = vulnerability_data
            .get("updated")
            .and_then(|v| v.as_str())
            .map(|s| s.to_string());

        let reference = vulnerability_data
            .get("reference")
            .and_then(|v| v.as_str())
            .map(|s| s.to_string());

        let description = vulnerability_data
            .get("description")
            .and_then(|v| v.as_str())
            .map(|s| s.to_string());

        let detection_time = source
            .get("timestamp")
            .or_else(|| source.get("@timestamp"))
            .or_else(|| source.get("vulnerability.detection_time"))
            .and_then(|v| v.as_str())
            .map(|s| s.to_string());

        let agent_name = source
            .get("agent")
            .and_then(|a| a.get("name"))
            .and_then(|v| v.as_str())
            .map(|s| s.to_string());

        let cvss = self.parse_cvss_scores(vulnerability_data);

        Ok(Vulnerability {
            cve,
            title,
            severity,
            published,
            updated,
            reference,
            description,
            cvss,
            detection_time,
            agent_id: Some(agent_id.to_string()),
            agent_name,
        })
    }

    fn parse_cvss_scores(&self, vulnerability_data: &Value) -> Option<CvssScore> {
        let cvss2 = vulnerability_data
            .get("cvss2")
            .map(|cvss2_data| CvssDetails {
                vector: cvss2_data
                    .get("vector")
                    .and_then(|v| v.as_str())
                    .map(|s| s.to_string()),
                base_score: cvss2_data.get("base_score").and_then(|v| v.as_f64()),
            });

        let cvss3 = vulnerability_data
            .get("cvss3")
            .map(|cvss3_data| CvssDetails {
                vector: cvss3_data
                    .get("vector")
                    .and_then(|v| v.as_str())
                    .map(|s| s.to_string()),
                base_score: cvss3_data.get("base_score").and_then(|v| v.as_f64()),
            });

        if cvss2.is_some() || cvss3.is_some() {
            Some(CvssScore { cvss2, cvss3 })
        } else {
            None
        }
    }

    pub async fn get_critical_vulnerabilities(
        &mut self,
        agent_id: &str,
        limit: Option<u32>,
    ) -> Result<Vec<Vulnerability>, WazuhApiError> {
        debug!(%agent_id, "Getting critical vulnerabilities");
        self.get_agent_vulnerabilities(
            agent_id,
            limit,
            None,
            Some(VulnerabilitySeverity::Critical),
        )
        .await
    }

    pub async fn get_high_vulnerabilities(
        &mut self,
        agent_id: &str,
        limit: Option<u32>,
    ) -> Result<Vec<Vulnerability>, WazuhApiError> {
        debug!(%agent_id, "Getting high severity vulnerabilities");
        self.get_agent_vulnerabilities(agent_id, limit, None, Some(VulnerabilitySeverity::High))
            .await
    }

    pub async fn get_medium_vulnerabilities(
        &mut self,
        agent_id: &str,
        limit: Option<u32>,
    ) -> Result<Vec<Vulnerability>, WazuhApiError> {
        debug!(%agent_id, "Getting medium severity vulnerabilities");
        self.get_agent_vulnerabilities(
            agent_id,
            limit,
            None,
            Some(VulnerabilitySeverity::Medium),
        )
        .await
    }

    pub async fn get_low_vulnerabilities(
        &mut self,
        agent_id: &str,
        limit: Option<u32>,
    ) -> Result<Vec<Vulnerability>, WazuhApiError> {
        debug!(%agent_id, "Getting low severity vulnerabilities");
        self.get_agent_vulnerabilities(agent_id, limit, None, Some(VulnerabilitySeverity::Low))
            .await
    }

    pub async fn get_agent_packages(
        &mut self,
        agent_id: &str,
        limit: Option<u32>,
        offset: Option<u32>,
        search: Option<&str>,
    ) -> Result<Vec<Package>, WazuhApiError> {
        debug!(%agent_id, ?search, "Getting packages for agent");

        let mut query_params = Vec::new();

        if let Some(limit) = limit {
            query_params.push(("limit", limit.to_string()));
        }
        if let Some(offset) = offset {
            query_params.push(("offset", offset.to_string()));
        }
        if let Some(search) = search {
            query_params.push(("search", search.to_string()));
        }

        let query_params_ref: Vec<(&str, &str)> =
            query_params.iter().map(|(k, v)| (*k, v.as_str())).collect();

        let endpoint = format!("/syscollector/{}/packages", agent_id);
        let response = self
            .api_client
            .make_request(
                Method::GET,
                &endpoint,
                None,
                if query_params_ref.is_empty() {
                    None
                } else {
                    Some(&query_params_ref)
                },
            )
            .await?;

        let packages_data = response
            .get("data")
            .and_then(|d| d.get("affected_items"))
            .ok_or_else(|| {
                WazuhApiError::ApiError(
                    "Missing 'data.affected_items' in packages response".to_string(),
                )
            })?;

        let packages: Vec<Package> = serde_json::from_value(packages_data.clone())?;
        info!(%agent_id, "Retrieved {} packages", packages.len());
        Ok(packages)
    }

    pub async fn get_agent_processes(
        &mut self,
        agent_id: &str,
        limit: Option<u32>,
        offset: Option<u32>,
        search: Option<&str>,
    ) -> Result<Vec<Process>, WazuhApiError> {
        debug!(%agent_id, ?search, "Getting processes for agent");

        let mut query_params = Vec::new();

        if let Some(limit) = limit {
            query_params.push(("limit", limit.to_string()));
        }
        if let Some(offset) = offset {
            query_params.push(("offset", offset.to_string()));
        }
        if let Some(search) = search {
            query_params.push(("search", search.to_string()));
        }

        let query_params_ref: Vec<(&str, &str)> =
            query_params.iter().map(|(k, v)| (*k, v.as_str())).collect();

        let endpoint = format!("/syscollector/{}/processes", agent_id);
        let response = self
            .api_client
            .make_request(
                Method::GET,
                &endpoint,
                None,
                if query_params_ref.is_empty() {
                    None
                } else {
                    Some(&query_params_ref)
                },
            )
            .await?;

        let processes_data = response
            .get("data")
            .and_then(|d| d.get("affected_items"))
            .ok_or_else(|| {
                WazuhApiError::ApiError(
                    "Missing 'data.affected_items' in processes response".to_string(),
                )
            })?;

        let processes: Vec<Process> = serde_json::from_value(processes_data.clone())?;
        info!(%agent_id, "Retrieved {} processes", processes.len());
        Ok(processes)
    }

    pub async fn get_agent_ports(
        &mut self,
        agent_id: &str,
        limit: Option<u32>,
        offset: Option<u32>,
        protocol: Option<&str>,
    ) -> Result<Vec<Port>, WazuhApiError> {
        debug!(%agent_id, ?protocol, "Getting ports for agent");

        let mut query_params = Vec::new();

        if let Some(limit) = limit {
            query_params.push(("limit", limit.to_string()));
        }
        if let Some(offset) = offset {
            query_params.push(("offset", offset.to_string()));
        }
        if let Some(protocol) = protocol {
            query_params.push(("protocol", protocol.to_string()));
        }

        let query_params_ref: Vec<(&str, &str)> =
            query_params.iter().map(|(k, v)| (*k, v.as_str())).collect();

        let endpoint = format!("/syscollector/{}/ports", agent_id);
        let response = self
            .api_client
            .make_request(
                Method::GET,
                &endpoint,
                None,
                if query_params_ref.is_empty() {
                    None
                } else {
                    Some(&query_params_ref)
                },
            )
            .await?;

        let ports_data = response
            .get("data")
            .and_then(|d| d.get("affected_items"))
            .ok_or_else(|| {
                WazuhApiError::ApiError(
                    "Missing 'data.affected_items' in ports response".to_string(),
                )
            })?;

        let ports: Vec<Port> = serde_json::from_value(ports_data.clone())?;
        info!(%agent_id, "Retrieved {} ports", ports.len());
        Ok(ports)
    }

    pub async fn get_vulnerability_summary(
        &mut self,
        agent_id: &str,
    ) -> Result<Option<VulnerabilitySummaryResponseData>, WazuhApiError> {
        debug!(%agent_id, "Getting vulnerability summary");

        let query_body = json!({
            "size": 0,
            "query": {
                "bool": {
                    "must": [
                        {
                            "term": {
                                "agent.id": agent_id
                            }
                        }
                    ]
                }
            },
            "aggs": {
                "severity_counts": {
                    "terms": {
                        "field": "vulnerability.severity",
                        "size": 10
                    }
                }
            }
        });

        let endpoint = "/wazuh-states-vulnerabilities*/_search";
        match self
            .indexer_client
            .make_indexer_request(Method::POST, endpoint, Some(query_body))
            .await
        {
            Ok(response_value) => {
                let aggregations = response_value
                    .get("aggregations")
                    .and_then(|aggs| aggs.get("severity_counts"))
                    .and_then(|severity| severity.get("buckets"))
                    .and_then(|buckets| buckets.as_array());

                if let Some(buckets) = aggregations {
                    let mut critical = 0;
                    let mut high = 0;
                    let mut medium = 0;
                    let mut low = 0;

                    for bucket in buckets {
                        if let (Some(key), Some(count)) = (
                            bucket.get("key").and_then(|k| k.as_str()),
                            bucket.get("doc_count").and_then(|c| c.as_i64()),
                        ) {
                            if let Some(severity) = VulnerabilitySeverity::from_str(key) {
                                match severity {
                                    VulnerabilitySeverity::Critical => critical = count as i32,
                                    VulnerabilitySeverity::High => high = count as i32,
                                    VulnerabilitySeverity::Medium => medium = count as i32,
                                    VulnerabilitySeverity::Low => low = count as i32,
                                }
                            }
                        }
                    }

                    let summary = VulnerabilitySummaryResponseData {
                        agent_id: agent_id.to_string(),
                        summary: VulnerabilitySummaryCounts {
                            critical,
                            high,
                            medium,
                            low,
                        },
                    };

                    info!(%agent_id, "Retrieved vulnerability summary");
                    Ok(Some(summary))
                } else {
                    info!(%agent_id, "No vulnerability data found for summary");
                    Ok(None)
                }
            }
            Err(e) => {
                warn!(%agent_id, "Failed to get vulnerability summary: {}", e);
                Ok(None)
            }
        }
    }

    pub async fn search_package(
        &mut self,
        package_name: &str,
        agent_ids: Option<&[String]>,
    ) -> Result<Vec<(String, Vec<Package>)>, WazuhApiError> {
        debug!(%package_name, "Searching for package across agents");

        let mut results = Vec::new();

        if let Some(agent_ids) = agent_ids {
            for agent_id in agent_ids {
                match self
                    .get_agent_packages(agent_id, None, None, Some(package_name))
                    .await
                {
                    Ok(packages) => {
                        if !packages.is_empty() {
                            results.push((agent_id.clone(), packages));
                        }
                    }
                    Err(e) => {
                        debug!(%agent_id, %package_name, "Failed to get packages: {}", e);
                    }
                }
            }
        }

        info!(%package_name, "Found package in {} agents", results.len());
        Ok(results)
    }

    pub async fn get_agents_with_vulnerability(
        &mut self,
        cve: &str,
        agent_ids: &[String],
        limit: Option<u32>,
    ) -> Result<Vec<String>, WazuhApiError> {
        debug!(%cve, "Finding agents with specific vulnerability");

        let mut affected_agents = Vec::new();

        for agent_id in agent_ids {
            match self
                .get_agent_vulnerabilities(agent_id, limit, None, None)
                .await
            {
                Ok(vulnerabilities) => {
                    if vulnerabilities.iter().any(|v| v.cve == cve) {
                        affected_agents.push(agent_id.clone());
                    }
                }
                Err(e) => {
                    debug!(%agent_id, %cve, "Failed to get vulnerabilities: {}", e);
                }
            }
        }

        info!(%cve, "Found {} agents with vulnerability", affected_agents.len());
        Ok(affected_agents)
    }

    /// Get vulnerabilities with severity at or above the specified level
    pub async fn get_vulnerabilities_by_min_severity(
        &mut self,
        agent_id: &str,
        min_severity: VulnerabilitySeverity,
        limit: Option<u32>,
        offset: Option<u32>,
    ) -> Result<Vec<Vulnerability>, WazuhApiError> {
        debug!(%agent_id, ?min_severity, "Getting vulnerabilities with minimum severity");

        // Get all vulnerabilities and filter by severity level
        let all_vulnerabilities = self
            .get_agent_vulnerabilities(agent_id, limit, offset, None)
            .await?;

        let filtered: Vec<Vulnerability> = all_vulnerabilities
            .into_iter()
            .filter(|vuln| match (vuln.severity, min_severity) {
                (VulnerabilitySeverity::Critical, _) => true,
                (VulnerabilitySeverity::High, VulnerabilitySeverity::Critical) => false,
                (VulnerabilitySeverity::High, _) => true,
                (
                    VulnerabilitySeverity::Medium,
                    VulnerabilitySeverity::Critical | VulnerabilitySeverity::High,
                ) => false,
                (VulnerabilitySeverity::Medium, _) => true,
                (VulnerabilitySeverity::Low, VulnerabilitySeverity::Low) => true,
                (VulnerabilitySeverity::Low, _) => false,
            })
            .collect();

        info!(%agent_id, ?min_severity, "Found {} vulnerabilities at or above severity level", filtered.len());
        Ok(filtered)
    }

    /// Get vulnerabilities for multiple severity levels
    pub async fn get_vulnerabilities_by_severities(
        &mut self,
        agent_id: &str,
        severities: &[VulnerabilitySeverity],
        limit: Option<u32>,
        offset: Option<u32>,
    ) -> Result<Vec<Vulnerability>, WazuhApiError> {
        debug!(%agent_id, ?severities, "Getting vulnerabilities for multiple severity levels");

        let mut all_vulnerabilities = Vec::new();

        for &severity in severities {
            let vulns = self
                .get_agent_vulnerabilities(agent_id, limit, offset, Some(severity))
                .await?;
            all_vulnerabilities.extend(vulns);
        }

        // Remove duplicates based on CVE
        all_vulnerabilities.sort_by(|a, b| a.cve.cmp(&b.cve));
        all_vulnerabilities.dedup_by(|a, b| a.cve == b.cve);

        info!(%agent_id, ?severities, "Found {} unique vulnerabilities", all_vulnerabilities.len());
        Ok(all_vulnerabilities)
    }

    // Syscollector endpoints

    /// Get hardware information for an agent
    pub async fn get_hardware_info(
        &mut self,
        agent_id: &str,
        limit: Option<u32>,
        offset: Option<u32>,
        select: Option<&str>,
    ) -> Result<Vec<SyscollectorHardware>, WazuhApiError> {
        debug!(%agent_id, "Getting hardware info for agent");

        let mut query_params = Vec::new();

        if let Some(limit) = limit {
            query_params.push(("limit", limit.to_string()));
        }
        if let Some(offset) = offset {
            query_params.push(("offset", offset.to_string()));
        }
        if let Some(select) = select {
            query_params.push(("select", select.to_string()));
        }

        let query_params_ref: Vec<(&str, &str)> =
            query_params.iter().map(|(k, v)| (*k, v.as_str())).collect();

        let endpoint = format!("/syscollector/{}/hardware", agent_id);
        let response = self
            .api_client
            .make_request(
                Method::GET,
                &endpoint,
                None,
                if query_params_ref.is_empty() {
                    None
                } else {
                    Some(&query_params_ref)
                },
            )
            .await?;

        let hardware_data = response
            .get("data")
            .and_then(|d| d.get("affected_items"))
            .ok_or_else(|| {
                WazuhApiError::ApiError(
                    "Missing 'data.affected_items' in hardware response".to_string(),
                )
            })?;

        let hardware: Vec<SyscollectorHardware> = serde_json::from_value(hardware_data.clone())?;
        info!(%agent_id, "Retrieved {} hardware info items", hardware.len());
        Ok(hardware)
    }

    /// Get OS information for an agent
    pub async fn get_os_info(
        &mut self,
        agent_id: &str,
        limit: Option<u32>,
        offset: Option<u32>,
        select: Option<&str>,
    ) -> Result<Vec<SyscollectorOS>, WazuhApiError> {
        debug!(%agent_id, "Getting OS info for agent");

        let mut query_params = Vec::new();

        if let Some(limit) = limit {
            query_params.push(("limit", limit.to_string()));
        }
        if let Some(offset) = offset {
            query_params.push(("offset", offset.to_string()));
        }
        if let Some(select) = select {
            query_params.push(("select", select.to_string()));
        }

        let query_params_ref: Vec<(&str, &str)> =
            query_params.iter().map(|(k, v)| (*k, v.as_str())).collect();

        let endpoint = format!("/syscollector/{}/os", agent_id);
        let response = self
            .api_client
            .make_request(
                Method::GET,
                &endpoint,
                None,
                if query_params_ref.is_empty() {
                    None
                } else {
                    Some(&query_params_ref)
                },
            )
            .await?;

        let os_data = response
            .get("data")
            .and_then(|d| d.get("affected_items"))
            .ok_or_else(|| {
                WazuhApiError::ApiError("Missing 'data.affected_items' in OS response".to_string())
            })?;

        let os_info: Vec<SyscollectorOS> = serde_json::from_value(os_data.clone())?;
        info!(%agent_id, "Retrieved {} OS info items", os_info.len());
        Ok(os_info)
    }

    /// Get network interfaces for an agent
    pub async fn get_network_interfaces(
        &mut self,
        agent_id: &str,
        limit: Option<u32>,
        offset: Option<u32>,
        select: Option<&str>,
    ) -> Result<Vec<SyscollectorNetworkInterface>, WazuhApiError> {
        debug!(%agent_id, "Getting network interfaces for agent");

        let mut query_params = Vec::new();

        if let Some(limit) = limit {
            query_params.push(("limit", limit.to_string()));
        }
        if let Some(offset) = offset {
            query_params.push(("offset", offset.to_string()));
        }
        if let Some(select) = select {
            query_params.push(("select", select.to_string()));
        }

        let query_params_ref: Vec<(&str, &str)> =
            query_params.iter().map(|(k, v)| (*k, v.as_str())).collect();

        let endpoint = format!("/syscollector/{}/netiface", agent_id);
        let response = self
            .api_client
            .make_request(
                Method::GET,
                &endpoint,
                None,
                if query_params_ref.is_empty() {
                    None
                } else {
                    Some(&query_params_ref)
                },
            )
            .await?;

        let interfaces_data = response
            .get("data")
            .and_then(|d| d.get("affected_items"))
            .ok_or_else(|| {
                WazuhApiError::ApiError(
                    "Missing 'data.affected_items' in network interfaces response".to_string(),
                )
            })?;

        let interfaces: Vec<SyscollectorNetworkInterface> =
            serde_json::from_value(interfaces_data.clone())?;
        info!(%agent_id, "Retrieved {} network interfaces", interfaces.len());
        Ok(interfaces)
    }

    /// Get network addresses for an agent
    pub async fn get_network_addresses(
        &mut self,
        agent_id: &str,
        limit: Option<u32>,
        offset: Option<u32>,
        select: Option<&str>,
    ) -> Result<Vec<SyscollectorNetworkAddress>, WazuhApiError> {
        debug!(%agent_id, "Getting network addresses for agent");

        let mut query_params = Vec::new();

        if let Some(limit) = limit {
            query_params.push(("limit", limit.to_string()));
        }
        if let Some(offset) = offset {
            query_params.push(("offset", offset.to_string()));
        }
        if let Some(select) = select {
            query_params.push(("select", select.to_string()));
        }

        let query_params_ref: Vec<(&str, &str)> =
            query_params.iter().map(|(k, v)| (*k, v.as_str())).collect();

        let endpoint = format!("/syscollector/{}/netaddr", agent_id);
        let response = self
            .api_client
            .make_request(
                Method::GET,
                &endpoint,
                None,
                if query_params_ref.is_empty() {
                    None
                } else {
                    Some(&query_params_ref)
                },
            )
            .await?;

        let addresses_data = response
            .get("data")
            .and_then(|d| d.get("affected_items"))
            .ok_or_else(|| {
                WazuhApiError::ApiError(
                    "Missing 'data.affected_items' in network addresses response".to_string(),
                )
            })?;

        let addresses: Vec<SyscollectorNetworkAddress> =
            serde_json::from_value(addresses_data.clone())?;
        info!(%agent_id, "Retrieved {} network addresses", addresses.len());
        Ok(addresses)
    }

    /// Get network protocols for an agent
    pub async fn get_network_protocols(
        &mut self,
        agent_id: &str,
        limit: Option<u32>,
        offset: Option<u32>,
        select: Option<&str>,
    ) -> Result<Vec<SyscollectorNetworkProtocol>, WazuhApiError> {
        debug!(%agent_id, "Getting network protocols for agent");

        let mut query_params = Vec::new();

        if let Some(limit) = limit {
            query_params.push(("limit", limit.to_string()));
        }
        if let Some(offset) = offset {
            query_params.push(("offset", offset.to_string()));
        }
        if let Some(select) = select {
            query_params.push(("select", select.to_string()));
        }

        let query_params_ref: Vec<(&str, &str)> =
            query_params.iter().map(|(k, v)| (*k, v.as_str())).collect();

        let endpoint = format!("/syscollector/{}/netproto", agent_id);
        let response = self
            .api_client
            .make_request(
                Method::GET,
                &endpoint,
                None,
                if query_params_ref.is_empty() {
                    None
                } else {
                    Some(&query_params_ref)
                },
            )
            .await?;

        let protocols_data = response
            .get("data")
            .and_then(|d| d.get("affected_items"))
            .ok_or_else(|| {
                WazuhApiError::ApiError(
                    "Missing 'data.affected_items' in network protocols response".to_string(),
                )
            })?;

        let protocols: Vec<SyscollectorNetworkProtocol> =
            serde_json::from_value(protocols_data.clone())?;
        info!(%agent_id, "Retrieved {} network protocols", protocols.len());
        Ok(protocols)
    }

    /// Get hotfixes (Windows updates) for an agent
    pub async fn get_hotfixes(
        &mut self,
        agent_id: &str,
        limit: Option<u32>,
        offset: Option<u32>,
        select: Option<&str>,
    ) -> Result<Vec<SyscollectorHotfix>, WazuhApiError> {
        debug!(%agent_id, "Getting hotfixes for agent");

        let mut query_params = Vec::new();

        if let Some(limit) = limit {
            query_params.push(("limit", limit.to_string()));
        }
        if let Some(offset) = offset {
            query_params.push(("offset", offset.to_string()));
        }
        if let Some(select) = select {
            query_params.push(("select", select.to_string()));
        }

        let query_params_ref: Vec<(&str, &str)> =
            query_params.iter().map(|(k, v)| (*k, v.as_str())).collect();

        let endpoint = format!("/syscollector/{}/hotfixes", agent_id);
        let response = self
            .api_client
            .make_request(
                Method::GET,
                &endpoint,
                None,
                if query_params_ref.is_empty() {
                    None
                } else {
                    Some(&query_params_ref)
                },
            )
            .await?;

        let hotfixes_data = response
            .get("data")
            .and_then(|d| d.get("affected_items"))
            .ok_or_else(|| {
                WazuhApiError::ApiError(
                    "Missing 'data.affected_items' in hotfixes response".to_string(),
                )
            })?;

        let hotfixes: Vec<SyscollectorHotfix> = serde_json::from_value(hotfixes_data.clone())?;
        info!(%agent_id, "Retrieved {} hotfixes", hotfixes.len());
        Ok(hotfixes)
    }

    /// Get system users for an agent
    pub async fn get_users(
        &mut self,
        agent_id: &str,
        limit: Option<u32>,
        offset: Option<u32>,
        select: Option<&str>,
    ) -> Result<Vec<SyscollectorUser>, WazuhApiError> {
        debug!(%agent_id, "Getting users for agent");

        let mut query_params = Vec::new();

        if let Some(limit) = limit {
            query_params.push(("limit", limit.to_string()));
        }
        if let Some(offset) = offset {
            query_params.push(("offset", offset.to_string()));
        }
        if let Some(select) = select {
            query_params.push(("select", select.to_string()));
        }

        let query_params_ref: Vec<(&str, &str)> =
            query_params.iter().map(|(k, v)| (*k, v.as_str())).collect();

        let endpoint = format!("/syscollector/{}/users", agent_id);
        let response = self
            .api_client
            .make_request(
                Method::GET,
                &endpoint,
                None,
                if query_params_ref.is_empty() {
                    None
                } else {
                    Some(&query_params_ref)
                },
            )
            .await?;

        let users_data = response
            .get("data")
            .and_then(|d| d.get("affected_items"))
            .ok_or_else(|| {
                WazuhApiError::ApiError(
                    "Missing 'data.affected_items' in users response".to_string(),
                )
            })?;

        let users: Vec<SyscollectorUser> = serde_json::from_value(users_data.clone())?;
        info!(%agent_id, "Retrieved {} users", users.len());
        Ok(users)
    }

    /// Get system groups for an agent
    pub async fn get_groups(
        &mut self,
        agent_id: &str,
        limit: Option<u32>,
        offset: Option<u32>,
        select: Option<&str>,
    ) -> Result<Vec<SyscollectorGroup>, WazuhApiError> {
        debug!(%agent_id, "Getting groups for agent");

        let mut query_params = Vec::new();

        if let Some(limit) = limit {
            query_params.push(("limit", limit.to_string()));
        }
        if let Some(offset) = offset {
            query_params.push(("offset", offset.to_string()));
        }
        if let Some(select) = select {
            query_params.push(("select", select.to_string()));
        }

        let query_params_ref: Vec<(&str, &str)> =
            query_params.iter().map(|(k, v)| (*k, v.as_str())).collect();

        let endpoint = format!("/syscollector/{}/groups", agent_id);
        let response = self
            .api_client
            .make_request(
                Method::GET,
                &endpoint,
                None,
                if query_params_ref.is_empty() {
                    None
                } else {
                    Some(&query_params_ref)
                },
            )
            .await?;

        let groups_data = response
            .get("data")
            .and_then(|d| d.get("affected_items"))
            .ok_or_else(|| {
                WazuhApiError::ApiError(
                    "Missing 'data.affected_items' in groups response".to_string(),
                )
            })?;

        let groups: Vec<SyscollectorGroup> = serde_json::from_value(groups_data.clone())?;
        info!(%agent_id, "Retrieved {} groups", groups.len());
        Ok(groups)
    }

    /// Get system services for an agent
    pub async fn get_services(
        &mut self,
        agent_id: &str,
        limit: Option<u32>,
        offset: Option<u32>,
        select: Option<&str>,
    ) -> Result<Vec<SyscollectorService>, WazuhApiError> {
        debug!(%agent_id, "Getting services for agent");

        let mut query_params = Vec::new();

        if let Some(limit) = limit {
            query_params.push(("limit", limit.to_string()));
        }
        if let Some(offset) = offset {
            query_params.push(("offset", offset.to_string()));
        }
        if let Some(select) = select {
            query_params.push(("select", select.to_string()));
        }

        let query_params_ref: Vec<(&str, &str)> =
            query_params.iter().map(|(k, v)| (*k, v.as_str())).collect();

        let endpoint = format!("/syscollector/{}/services", agent_id);
        let response = self
            .api_client
            .make_request(
                Method::GET,
                &endpoint,
                None,
                if query_params_ref.is_empty() {
                    None
                } else {
                    Some(&query_params_ref)
                },
            )
            .await?;

        let services_data = response
            .get("data")
            .and_then(|d| d.get("affected_items"))
            .ok_or_else(|| {
                WazuhApiError::ApiError(
                    "Missing 'data.affected_items' in services response".to_string(),
                )
            })?;

        let services: Vec<SyscollectorService> = serde_json::from_value(services_data.clone())?;
        info!(%agent_id, "Retrieved {} services", services.len());
        Ok(services)
    }

    /// Get browser extensions for an agent
    pub async fn get_browser_extensions(
        &mut self,
        agent_id: &str,
        limit: Option<u32>,
        offset: Option<u32>,
        select: Option<&str>,
    ) -> Result<Vec<SyscollectorBrowserExtension>, WazuhApiError> {
        debug!(%agent_id, "Getting browser extensions for agent");

        let mut query_params = Vec::new();

        if let Some(limit) = limit {
            query_params.push(("limit", limit.to_string()));
        }
        if let Some(offset) = offset {
            query_params.push(("offset", offset.to_string()));
        }
        if let Some(select) = select {
            query_params.push(("select", select.to_string()));
        }

        let query_params_ref: Vec<(&str, &str)> =
            query_params.iter().map(|(k, v)| (*k, v.as_str())).collect();

        let endpoint = format!("/syscollector/{}/browser_extensions", agent_id);
        let response = self
            .api_client
            .make_request(
                Method::GET,
                &endpoint,
                None,
                if query_params_ref.is_empty() {
                    None
                } else {
                    Some(&query_params_ref)
                },
            )
            .await?;

        let extensions_data = response
            .get("data")
            .and_then(|d| d.get("affected_items"))
            .ok_or_else(|| {
                WazuhApiError::ApiError(
                    "Missing 'data.affected_items' in browser extensions response".to_string(),
                )
            })?;

        let extensions: Vec<SyscollectorBrowserExtension> =
            serde_json::from_value(extensions_data.clone())?;
        info!(%agent_id, "Retrieved {} browser extensions", extensions.len());
        Ok(extensions)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_vulnerability_severity_to_string() {
        assert_eq!(VulnerabilitySeverity::Critical.to_string(), "Critical");
        assert_eq!(VulnerabilitySeverity::High.to_string(), "High");
        assert_eq!(VulnerabilitySeverity::Medium.to_string(), "Medium");
        assert_eq!(VulnerabilitySeverity::Low.to_string(), "Low");
    }

    #[test]
    fn test_vulnerability_severity_from_str() {
        assert_eq!(
            VulnerabilitySeverity::from_str("critical"),
            Some(VulnerabilitySeverity::Critical)
        );
        assert_eq!(
            VulnerabilitySeverity::from_str("HIGH"),
            Some(VulnerabilitySeverity::High)
        );
        assert_eq!(
            VulnerabilitySeverity::from_str("Medium"),
            Some(VulnerabilitySeverity::Medium)
        );
        assert_eq!(
            VulnerabilitySeverity::from_str("low"),
            Some(VulnerabilitySeverity::Low)
        );
        assert_eq!(VulnerabilitySeverity::from_str("invalid"), None);
    }

    #[test]
    fn test_vulnerability_severity_all() {
        let all = VulnerabilitySeverity::all();
        assert_eq!(all.len(), 4);
        assert_eq!(all[0], VulnerabilitySeverity::Critical);
        assert_eq!(all[1], VulnerabilitySeverity::High);
        assert_eq!(all[2], VulnerabilitySeverity::Medium);
        assert_eq!(all[3], VulnerabilitySeverity::Low);
    }

    #[test]
    fn test_syscollector_hardware_deserialization() {
        let json = r#"{
            "board_serial": "ABC123",
            "cpu": {
                "name": "Intel Core i7",
                "cores": 8,
                "mhz": 3600.0
            },
            "ram": {
                "total": 16384,
                "free": 8192
            }
        }"#;

        let hardware: Result<SyscollectorHardware, _> = serde_json::from_str(json);
        assert!(hardware.is_ok());
        let hw = hardware.unwrap();
        assert_eq!(hw.board_serial, Some("ABC123".to_string()));
        assert!(hw.cpu.is_some());
        assert!(hw.ram.is_some());
    }

    #[test]
    fn test_syscollector_os_deserialization() {
        let json = r#"{
            "hostname": "test-host",
            "architecture": "x86_64",
            "version": "22.04",
            "os": {
                "name": "Ubuntu",
                "platform": "ubuntu",
                "version": "22.04"
            }
        }"#;

        let os: Result<SyscollectorOS, _> = serde_json::from_str(json);
        assert!(os.is_ok());
        let os_info = os.unwrap();
        assert_eq!(os_info.hostname, Some("test-host".to_string()));
        assert_eq!(os_info.version, Some("22.04".to_string()));
        assert_eq!(os_info.architecture, Some("x86_64".to_string()));
    }

    #[test]
    fn test_syscollector_network_interface_deserialization() {
        let json = r#"{
            "name": "eth0",
            "adapter": "Ethernet Adapter",
            "type": "ethernet",
            "state": "up",
            "mtu": 1500,
            "mac": "00:11:22:33:44:55"
        }"#;

        let iface: Result<SyscollectorNetworkInterface, _> = serde_json::from_str(json);
        assert!(iface.is_ok());
        let net = iface.unwrap();
        assert_eq!(net.name, Some("eth0".to_string()));
        assert_eq!(net.state, Some("up".to_string()));
        assert_eq!(net.mac, Some("00:11:22:33:44:55".to_string()));
    }

    #[test]
    fn test_syscollector_user_deserialization() {
        let json = r#"{
            "user": {
                "name": "testuser",
                "home": "/home/testuser"
            }
        }"#;

        let user: Result<SyscollectorUser, _> = serde_json::from_str(json);
        assert!(user.is_ok());
        let u = user.unwrap();
        assert!(u.user.is_some());
    }

    #[test]
    fn test_syscollector_service_deserialization() {
        let json = r#"{
            "service": {
                "name": "nginx"
            }
        }"#;

        let service: Result<SyscollectorService, _> = serde_json::from_str(json);
        assert!(service.is_ok());
        let svc = service.unwrap();
        assert!(svc.service.is_some());
    }

    #[test]
    fn test_vulnerability_client_creation() {
        let api_client = WazuhApiClient::new(
            "localhost".to_string(),
            55000,
            "wazuh".to_string(),
            "wazuh".to_string(),
            false,
        );
        let indexer_client = WazuhIndexerClient::new(
            "localhost".to_string(),
            9200,
            "admin".to_string(),
            "admin".to_string(),
            false,
        );

        let _vuln_client = VulnerabilityClient::new(api_client, indexer_client);
    }
}
