//! Vulnerability detection example for the Wazuh Rust client
//!
//! This example demonstrates:
//! - Comprehensive vulnerability scanning and assessment
//! - Package inventory and security analysis
//! - Process monitoring and threat detection
//! - Network port analysis and security assessment
//! - Risk prioritization and remediation guidance

use log::debug;
use std::collections::HashMap;
use std::env;
use tracing::{error, trace, warn};
use wazuh_client::{VulnerabilitySeverity, WazuhClientFactory};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::EnvFilter::from_default_env())
        .init();

    trace!("Starting example execution");

    println!("üîç Wazuh Rust Client - Vulnerability Detection Example");
    println!("======================================================");

    let factory = create_client_factory();

    trace!("Testing connectivity");
    println!("üîç Testing connectivity...");
    let connectivity = factory.test_connectivity().await?;
    if !connectivity.api_connected {
        error!(
            "‚ùå Cannot connect to Wazuh API: {}",
            connectivity.api_error.as_deref().unwrap_or("Unknown error")
        );
        return Err("API connectivity failed".into());
    }
    println!("‚úÖ Connected to Wazuh API");

    let mut vulnerability_client = factory.create_vulnerability_client();
    let mut agents_client = factory.create_agents_client();

    println!("\nü§ñ Agent Selection for Vulnerability Scanning");
    println!("==============================================");

    let agents = agents_client.get_active_agents().await?;

    if agents.is_empty() {
        println!("‚ùå No active agents found for vulnerability scanning");
        return Ok(());
    }

    println!("‚úÖ Found {} active agents for scanning", agents.len());
    for agent in agents.iter().take(5) {
        println!(
            "   üîπ Agent {}: {} ({})",
            agent.id,
            agent.name,
            agent.ip.as_deref().unwrap_or("N/A")
        );
    }

    println!("\nüö® Multi-Agent Vulnerability Assessment");
    println!("=======================================");

    // Global statistics across all agents
    let mut global_vulnerability_count = 0;
    let mut global_severity_counts: HashMap<VulnerabilitySeverity, u32> = HashMap::new();
    let mut global_cvss_scores: Vec<f64> = Vec::new();
    let mut agents_with_vulnerabilities = 0;
    let mut agents_without_vulnerabilities = 0;

    // Process each agent
    for (agent_index, agent) in agents.iter().enumerate() {
        println!(
            "\nüéØ Agent {}/{}: {} (ID: {})",
            agent_index + 1,
            agents.len(),
            agent.name,
            agent.id
        );
        println!("   IP: {}", agent.ip.as_deref().unwrap_or("N/A"));
        println!("   Status: {}", agent.status);
        println!(
            "   OS: {}",
            agent
                .os
                .as_ref()
                .map(|os| os.to_string())
                .unwrap_or("Unknown".to_string())
        );
        println!(
            "   Version: {}",
            agent.version.as_deref().unwrap_or("Unknown")
        );

        // First try to get critical vulnerabilities
        println!("   üîç Checking for critical vulnerabilities...");
        match vulnerability_client
            .get_critical_vulnerabilities(&agent.id, None)
            .await
        {
            Ok(vulnerabilities) => {
                if vulnerabilities.is_empty() {
                    println!("   ‚úÖ No critical vulnerabilities found");

                    // Now get all vulnerabilities to see what's actually there
                    println!("   üîç Checking for all vulnerabilities...");
                    match vulnerability_client
                        .get_agent_vulnerabilities(&agent.id, Some(50), None, None)
                        .await
                    {
                        Ok(all_vulns) => {
                            if all_vulns.is_empty() {
                                println!("   ‚úÖ No vulnerabilities of any severity found");
                                agents_without_vulnerabilities += 1;
                            } else {
                                println!("   ‚ö†Ô∏è  Found {} total vulnerabilities", all_vulns.len());
                                agents_with_vulnerabilities += 1;
                                global_vulnerability_count += all_vulns.len();

                                // Process all vulnerabilities for statistics
                                let mut agent_severity_counts: HashMap<VulnerabilitySeverity, u32> =
                                    HashMap::new();
                                let mut agent_cvss_scores: Vec<f64> = Vec::new();

                                for vuln in &all_vulns {
                                    *global_severity_counts.entry(vuln.severity).or_insert(0) += 1;
                                    *agent_severity_counts.entry(vuln.severity).or_insert(0) += 1;

                                    if let Some(cvss) = &vuln.cvss {
                                        if let Some(cvss3) = &cvss.cvss3 {
                                            if let Some(score) = cvss3.base_score {
                                                global_cvss_scores.push(score);
                                                agent_cvss_scores.push(score);
                                            }
                                        } else if let Some(cvss2) = &cvss.cvss2 {
                                            if let Some(score) = cvss2.base_score {
                                                global_cvss_scores.push(score);
                                                agent_cvss_scores.push(score);
                                            }
                                        }
                                    }
                                }

                                println!("   üìä Severity Distribution:");
                                for (severity, count) in &agent_severity_counts {
                                    println!("      {}: {} vulnerabilities", severity, count);
                                }

                                if !agent_cvss_scores.is_empty() {
                                    let avg_score = agent_cvss_scores.iter().sum::<f64>()
                                        / agent_cvss_scores.len() as f64;
                                    let max_score =
                                        agent_cvss_scores.iter().fold(0.0f64, |a, &b| a.max(b));
                                    println!(
                                        "   üìà CVSS Scores: Avg {:.1}, Max {:.1}",
                                        avg_score, max_score
                                    );
                                }

                                println!("   üî• Sample Vulnerabilities (First 5):");
                                for (idx, vuln) in all_vulns.iter().take(5).enumerate() {
                                    println!("      ‚ïê‚ïê‚ïê Vulnerability #{} ‚ïê‚ïê‚ïê", idx + 1);
                                    println!("      CVE: {}", vuln.cve);
                                    println!("      Title: {}", vuln.title);
                                    println!("      Severity: {}", vuln.severity);

                                    if let Some(cvss) = &vuln.cvss {
                                        if let Some(cvss3) = &cvss.cvss3 {
                                            if let Some(score) = cvss3.base_score {
                                                println!("      CVSS v3 Score: {:.1}", score);
                                            }
                                            if let Some(vector) = &cvss3.vector {
                                                println!("      CVSS v3 Vector: {}", vector);
                                            }
                                        }
                                        if let Some(cvss2) = &cvss.cvss2 {
                                            if let Some(score) = cvss2.base_score {
                                                println!("      CVSS v2 Score: {:.1}", score);
                                            }
                                        }
                                    }

                                    if let Some(published) = &vuln.published {
                                        println!("      Published: {}", published);
                                    }
                                    println!();
                                }

                                if all_vulns.len() > 5 {
                                    println!(
                                        "      ... and {} more vulnerabilities",
                                        all_vulns.len() - 5
                                    );
                                }
                            }
                        }
                        Err(e) => {
                            println!("   ‚ùå Failed to get all vulnerabilities: {}", e);
                            agents_without_vulnerabilities += 1;
                        }
                    }
                } else {
                    println!(
                        "   üö® Found {} CRITICAL vulnerabilities",
                        vulnerabilities.len()
                    );
                    agents_with_vulnerabilities += 1;
                    global_vulnerability_count += vulnerabilities.len();

                    // Analyze vulnerabilities by severity for this agent
                    let mut agent_severity_counts: HashMap<VulnerabilitySeverity, u32> =
                        HashMap::new();
                    let mut agent_cvss_scores: Vec<f64> = Vec::new();

                    for vuln in &vulnerabilities {
                        *global_severity_counts.entry(vuln.severity).or_insert(0) += 1;
                        *agent_severity_counts.entry(vuln.severity).or_insert(0) += 1;

                        if let Some(cvss) = &vuln.cvss {
                            if let Some(cvss3) = &cvss.cvss3 {
                                if let Some(score) = cvss3.base_score {
                                    global_cvss_scores.push(score);
                                    agent_cvss_scores.push(score);
                                }
                            } else if let Some(cvss2) = &cvss.cvss2 {
                                if let Some(score) = cvss2.base_score {
                                    global_cvss_scores.push(score);
                                    agent_cvss_scores.push(score);
                                }
                            }
                        }
                    }

                    println!("   üìä Severity Distribution:");
                    for (severity, count) in &agent_severity_counts {
                        println!("      {}: {} vulnerabilities", severity, count);
                    }

                    if !agent_cvss_scores.is_empty() {
                        let avg_score =
                            agent_cvss_scores.iter().sum::<f64>() / agent_cvss_scores.len() as f64;
                        let max_score = agent_cvss_scores.iter().fold(0.0f64, |a, &b| a.max(b));
                        println!(
                            "   üìà CVSS Scores: Avg {:.1}, Max {:.1}",
                            avg_score, max_score
                        );
                    }

                    println!("   üî• Detailed Vulnerability Information (First 20):");
                    for (idx, vuln) in vulnerabilities.iter().take(20).enumerate() {
                        println!("      ‚ïê‚ïê‚ïê Vulnerability #{} ‚ïê‚ïê‚ïê", idx + 1);
                        println!("      CVE: {}", vuln.cve);
                        println!("      Title: {}", vuln.title);
                        println!("      Severity: {}", vuln.severity);

                        if let Some(cvss) = &vuln.cvss {
                            if let Some(cvss3) = &cvss.cvss3 {
                                println!("      CVSS v3.x:");
                                if let Some(score) = cvss3.base_score {
                                    println!("        Base Score: {:.1}", score);
                                }
                                if let Some(vector) = &cvss3.vector {
                                    println!("        Vector: {}", vector);
                                }
                            }
                            if let Some(cvss2) = &cvss.cvss2 {
                                println!("      CVSS v2.0:");
                                if let Some(score) = cvss2.base_score {
                                    println!("        Base Score: {:.1}", score);
                                }
                                if let Some(vector) = &cvss2.vector {
                                    println!("        Vector: {}", vector);
                                }
                            }
                        }

                        if let Some(detection_time) = &vuln.detection_time {
                            println!("      Detection Time: {}", detection_time);
                        }

                        if let Some(published) = &vuln.published {
                            println!("      Published: {}", published);
                        }

                        if let Some(updated) = &vuln.updated {
                            println!("      Updated: {}", updated);
                        }

                        if let Some(reference) = &vuln.reference {
                            println!("      Reference: {}", reference);
                        }

                        if let Ok(json_str) = serde_json::to_string_pretty(vuln) {
                            println!("      Raw JSON:");
                            for line in json_str.lines().take(10) {
                                println!("        {}", line);
                            }
                            if json_str.lines().count() > 10 {
                                println!("        ... (truncated)");
                            }
                        }

                        println!();
                    }

                    if vulnerabilities.len() > 20 {
                        println!(
                            "      ... and {} more vulnerabilities (showing first 20)",
                            vulnerabilities.len() - 20
                        );
                    }
                }

                match vulnerability_client
                    .get_vulnerability_summary(&agent.id)
                    .await
                {
                    Ok(summary) => {
                        println!("   üìä Summary available: ‚úÖ");
                        // Only show summary for first few agents to avoid overwhelming output
                        if agent_index < 2 {
                            if let Ok(pretty_summary) = serde_json::to_string_pretty(&summary) {
                                println!("   Summary details:\n{}", pretty_summary);
                            }
                        }
                    }
                    Err(e) => {
                        if e.to_string().contains("status 404 Not Found") {
                            println!("   üìä Summary: Not available (no vulnerability data)");
                        } else {
                            warn!("   üìä Summary error: {}", e);
                        }
                    }
                }
            }
            Err(e) => {
                if e.to_string().contains("status 404 Not Found") {
                    println!("   ‚ùå Vulnerability data not available for this agent");
                    agents_without_vulnerabilities += 1;
                } else {
                    warn!("   ‚ùå Failed to get vulnerabilities: {}", e);
                }
            }
        }

        if agent_index < agents.len() - 1 {
            tokio::time::sleep(tokio::time::Duration::from_millis(500)).await;
        }
    }

    println!("\nüåç Global Vulnerability Analysis Summary");
    println!("=======================================");
    println!("üìä Infrastructure Overview:");
    println!("   Total Agents: {}", agents.len());
    println!(
        "   Agents with Vulnerabilities: {}",
        agents_with_vulnerabilities
    );
    println!(
        "   Agents without Vulnerabilities: {}",
        agents_without_vulnerabilities
    );
    println!(
        "   Total Vulnerabilities Found: {}",
        global_vulnerability_count
    );

    if !global_severity_counts.is_empty() {
        println!("\nüìà Global Severity Distribution:");
        let mut sorted_severities: Vec<_> = global_severity_counts.iter().collect();
        // Sort by severity priority (Critical > High > Medium > Low), then by count
        sorted_severities.sort_by(|(sev_a, count_a), (sev_b, count_b)| {
            use VulnerabilitySeverity::*;
            let priority_a = match sev_a {
                Critical => 0,
                High => 1,
                Medium => 2,
                Low => 3,
            };
            let priority_b = match sev_b {
                Critical => 0,
                High => 1,
                Medium => 2,
                Low => 3,
            };
            priority_a
                .cmp(&priority_b)
                .then(std::cmp::Reverse(*count_a).cmp(&std::cmp::Reverse(*count_b)))
        });
        for (severity, count) in sorted_severities {
            println!("   {}: {} vulnerabilities", severity, count);
        }
    }

    if !global_cvss_scores.is_empty() {
        let global_avg_score =
            global_cvss_scores.iter().sum::<f64>() / global_cvss_scores.len() as f64;
        let global_max_score = global_cvss_scores.iter().fold(0.0f64, |a, &b| a.max(b));
        let global_min_score = global_cvss_scores.iter().fold(10.0f64, |a, &b| a.min(b));

        println!("\nüéØ Global CVSS Score Analysis:");
        println!("   Average CVSS Score: {:.1}", global_avg_score);
        println!("   Highest CVSS Score: {:.1}", global_max_score);
        println!("   Lowest CVSS Score: {:.1}", global_min_score);
        println!(
            "   Total Scored Vulnerabilities: {}",
            global_cvss_scores.len()
        );
    }

    println!("\n‚ö†Ô∏è  Risk Assessment:");
    let vulnerability_rate = (agents_with_vulnerabilities as f64 / agents.len() as f64) * 100.0;
    println!(
        "   Infrastructure Vulnerability Rate: {:.1}%",
        vulnerability_rate
    );

    if vulnerability_rate > 75.0 {
        println!("   üö® HIGH RISK: Most of your infrastructure has vulnerabilities");
    } else if vulnerability_rate > 50.0 {
        println!("   ‚ö†Ô∏è  MEDIUM RISK: Significant portion of infrastructure affected");
    } else if vulnerability_rate > 25.0 {
        println!("   ‚ö° LOW-MEDIUM RISK: Some agents need attention");
    } else {
        println!("   ‚úÖ LOW RISK: Most agents are clean");
    }

    if global_vulnerability_count > 0 {
        let avg_vulns_per_affected_agent =
            global_vulnerability_count as f64 / agents_with_vulnerabilities.max(1) as f64;
        println!(
            "   Average Vulnerabilities per Affected Agent: {:.1}",
            avg_vulns_per_affected_agent
        );

        // Enhanced risk assessment based on severity distribution
        let critical_count = global_severity_counts
            .get(&VulnerabilitySeverity::Critical)
            .unwrap_or(&0);
        let high_count = global_severity_counts
            .get(&VulnerabilitySeverity::High)
            .unwrap_or(&0);
        let medium_count = global_severity_counts
            .get(&VulnerabilitySeverity::Medium)
            .unwrap_or(&0);
        let low_count = global_severity_counts
            .get(&VulnerabilitySeverity::Low)
            .unwrap_or(&0);

        println!("\nüéØ Severity-Based Risk Analysis:");
        if *critical_count > 0 {
            println!(
                "   üö® CRITICAL ALERT: {} critical vulnerabilities require immediate attention!",
                critical_count
            );
        }
        if *high_count > 0 {
            println!(
                "   ‚ö†Ô∏è  HIGH PRIORITY: {} high-severity vulnerabilities need urgent patching",
                high_count
            );
        }
        if *medium_count > 0 {
            println!(
                "   üìã MEDIUM PRIORITY: {} medium-severity vulnerabilities for scheduled patching",
                medium_count
            );
        }
        if *low_count > 0 {
            println!(
                "   üìù LOW PRIORITY: {} low-severity vulnerabilities for maintenance windows",
                low_count
            );
        }

        let high_priority_vulns = critical_count + high_count;
        if high_priority_vulns > 0 {
            let high_priority_percentage =
                (high_priority_vulns as f64 / global_vulnerability_count as f64) * 100.0;
            println!(
                "   üî• High-Priority Vulnerabilities: {} ({:.1}% of total)",
                high_priority_vulns, high_priority_percentage
            );
        }
    }

    println!("\nüîç Multi-Agent Package Search");
    println!("=============================");

    let search_packages = vec!["openssl", "apache", "nginx", "ssh"];
    let all_agent_ids: Vec<String> = agents.iter().map(|a| a.id.clone()).collect();

    for package_name in search_packages {
        match vulnerability_client
            .search_package(package_name, Some(&all_agent_ids))
            .await
        {
            Ok(search_results) => {
                if !search_results.is_empty() {
                    println!(
                        "üîç Package '{}' found on {} agents:",
                        package_name,
                        search_results.len()
                    );
                    for (agent_id, packages) in search_results.iter().take(5) {
                        // Find agent name
                        let agent_name = agents
                            .iter()
                            .find(|a| a.id == *agent_id)
                            .map(|a| a.name.as_str())
                            .unwrap_or("Unknown");

                        println!("   ü§ñ Agent: {} ({})", agent_name, agent_id);
                        if packages.is_empty() {
                            println!("     No instances found");
                        } else {
                            for package in packages.iter().take(2) {
                                println!("     üì¶ {} v{}", package.name, package.version);
                                if let Some(arch) = &package.architecture {
                                    println!("        Architecture: {}", arch);
                                }
                            }
                            if packages.len() > 2 {
                                println!("        ... and {} more instances", packages.len() - 2);
                            }
                        }
                    }
                    if search_results.len() > 5 {
                        println!(
                            "   ... and {} more agents with this package",
                            search_results.len() - 5
                        );
                    }
                } else {
                    println!("üîç Package '{}': Not found on any agent", package_name);
                }
            }
            Err(e) => warn!("Failed to search for package '{}': {}", package_name, e),
        }
        println!();
    }

    Ok(())
}

fn create_client_factory() -> WazuhClientFactory {
    let api_host = env::var("WAZUH_API_HOST").unwrap_or_else(|_| "localhost".to_string());
    let api_port: u16 = env::var("WAZUH_API_PORT")
        .unwrap_or_else(|_| "55000".to_string())
        .parse()
        .unwrap_or(55000);
    let api_username = env::var("WAZUH_API_USERNAME").unwrap_or_else(|_| "wazuh".to_string());
    let api_password = env::var("WAZUH_API_PASSWORD").unwrap_or_else(|_| "wazuh".to_string());

    let indexer_host = env::var("WAZUH_INDEXER_HOST").unwrap_or_else(|_| "localhost".to_string());
    let indexer_port: u16 = env::var("WAZUH_INDEXER_PORT")
        .unwrap_or_else(|_| "9200".to_string())
        .parse()
        .unwrap_or(9200);
    let indexer_username =
        env::var("WAZUH_INDEXER_USERNAME").unwrap_or_else(|_| "admin".to_string());
    let indexer_password =
        env::var("WAZUH_INDEXER_PASSWORD").unwrap_or_else(|_| "admin".to_string());

    let verify_ssl = env::var("WAZUH_VERIFY_SSL")
        .unwrap_or_else(|_| "false".to_string())
        .parse()
        .unwrap_or(false);

    WazuhClientFactory::builder()
        .api_host(api_host)
        .api_port(api_port)
        .api_credentials(api_username, api_password)
        .indexer_host(indexer_host)
        .indexer_port(indexer_port)
        .indexer_credentials(indexer_username, indexer_password)
        .verify_ssl(verify_ssl)
        .protocol("https")
        .build()
}
